扩展方法:

https://www.cnblogs.com/ldp615/archive/2009/08/07/1541404.html

诊断日志

https://blog.csdn.net/ysj1163620987/article/details/109006868

https://www.cnblogs.com/wucy/p/13532534.html

### virtual & abstract

这两个限定词都是为了让子类进行重新定义，覆盖父类的定义。但是用法上差别很大。 

a) virtual修饰的方法必须有方法实现(哪怕只有一对大括号),abstract修饰的方法不能有实现。 

b) virtual可以被子类重写,abstract必须被子类重写 

c) 如果类中的某一函数被abstact修饰,则类名也必须用abstact修饰 

d) Abstract修饰的类不能被创建实例。 

e) C#中如果准备在子类重写父类的方法，则该方法在父类中必须用virtual修饰，在子类中必须用overide修饰，避免了程序员在子类中不小心重写了父类父类方法。 注：用abstract修饰的类只能被继承不能够被实例化。

### abstract & interface

### 文件流的使用错误

System.InvalidOperationException: Response Content-Length mismatch: too few bytes written

原因：一个保存为Excel的文件流，在使用前，必须设为流的当前位置为0，否则文件流被使用的时候，流的当前位置在流的末端1629，然后读流就会从索引1629开始读取，实际上流的最大索引是1628，就会引发无效操作异常System.InvalidOperationException。

解决方案: stream.Position = 0;

### 数据库连接的处理

若连接不能及时释放，引发连接池满的异常错误：InvalidOperationException: Timeout expired. The timeout expired waiting for a connection in the pool probably due to max connections reached.

利用Dispose方法和Finalize方法来保证一个对象正确而高效地被析构。

Finalize方法比Dispose方法更加安全，因为它由CLR保证调用，但是性能方面Finalize方法却要差的多。Dispose方法被使用者主动调用，而Finalize方法在对象被垃圾回收的第一轮回收后，由一个专用的.NET线程进行调用。Dispose方法不能保证被执行，而.NET的垃圾回收机制保证了拥有Finalize方法并且需要被调用的类型对象的Finalize方法被执行。调用Finalize方法涉及了一系列复杂的操作，性能代价非常高，程序员可以通过GC.SuppressFinalize方法通知.NET该对象的Finalize方法不需要被调用。有关Dispose和Finalize的类型设计应该参照上面的代码模板，以保证对象能够被高效和安全的释放。

### 调用WebServices

\1.   在VS中，添加服务引用--高级--添加web引用，直接输入webservice URL，然后直接实例化该命名空间下的类的对象，调用该接口下的各个方法即可。

\2.   动态生成代理类和实例，并调用指定类和方法。

### webservice远程访问的问题

在asp.net 开发的webservice本地测试可以运行，放在远程服务器上后访问却显示“测试窗体只能用于来自本地计算机的请求”。

解决方法： 在web.config的<system.web></system.web>加入

```
<webServices>
     <protocols>
      <add name="HttpSoap"/>
      <add name="HttpPost"/>
      <add name="HttpGet"/>
      <add name="Documentation"/>
     </protocols>
</webServices>
```

#### 发布的webservice服务接口的参数中**传入xml提示潜在危险值，无法正常调用。**

解决方案：在配置文件中的system.web中增加以下节点：

```
<system.web>
	<httpRuntime requestValidationMode="2.0" />
	<pages validateRequest="false"/>
</system.web>
```

### System.MissingMethodException: Method not found. 引用的dll文件找不到方法。

解决方案：引用程序集的版本冲突导致，重新添加引用并生成。插件化的缺点，没有有效的管理。

### VS2015中，特殊字符无法编译，以及报表乱码问题。

用VS2015打开并编译，定位到编译错误的文件，中文附近（.cs而不是可视化编辑视图）

```csharp
文件--高级保存选项--编码 改为 Unicode-8
```



### Razor Page

默认约定和路径。

Razor 页面需要一个根目录。默认情况下，该根目录是 ***Pages\***，位于Web应用程序项目的根目录中。

```
  services.AddMvc().AddRazorPagesOptions(options => {options.RootDirectory = "/Pagess"; });
```

自定义方法默认格式。

[ASP.NET Core - Razor页面之Handlers处理方法](https://www.cnblogs.com/tdfblog/p/razor-pages-handlers-in-asp-net-core.html)

[ASP.NET Core Razor 页面路由](https://www.cnblogs.com/tdfblog/p/razor-pages-route-in-asp-net-core.html)

[使用.net core基于Razor Pages开发网站一些工作笔记 - CloudH - 博客园](https://www.cnblogs.com/jessory/p/11041488.html)

[ASP.NET Core - Razor 页面介绍](https://www.cnblogs.com/tdfblog/p/razor-pages-in-asp-net-core.html)

[如何在ASP.NET Core 3.0 MVC中使用终结点路由_cxu0262的博客-CSDN博客](https://blog.csdn.net/cxu0262/article/details/106255838)

[Asp .Net Core Excel导入和导出](https://www.cnblogs.com/hulizhong/p/10840263.html)

[Asp.Net Core文件上传IFormFile](http://www.manongjc.com/detail/11-elathiirqewtydp.html)

[[.Net Core学习三\]基于Razor Page的增删改查_一入编程深似海-CSDN博客](https://blog.csdn.net/liuzishang/article/details/98940510?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

[Asp.Net core Razor页面的请求方法](https://www.cnblogs.com/shx666/p/7833899.html)



### Excel的读取和导出

[.NET导出Excel的四种方法及评测_Aspose](https://www.sohu.com/a/336656775_468635)

[【转】C# 异常处理 throw和throw ex的区别 try catch finally的执行顺序（return）](https://www.cnblogs.com/xdot/p/7421515.html)

[C#中的 Stream](https://www.cnblogs.com/whl4835349/p/9755710.html)

[c#常见stream操作_张乐超-CSDN博客](https://blog.csdn.net/abc456456456456/article/details/38469445/)

[C# Stream篇（-） -- Stream基类](https://www.cnblogs.com/crazytomato/p/8274803.html)



### XML的读取和导出

XML定义 xml文档中每一个对象都是一个节点 整个文档是一个文档节点 即Document节点 每个 XML 标签是一个元素节点 即ELEMENT节点 包含在 XML 元素中的文本是文本节点即Text节点 每一个 XML 属性是一个属性节点 即Attr节点 一个xml文档由根节点，元素节点，属性节点，文本节点构成，都继承接口Node。 所以XmlElement和XmlNode的区别是：节点不一定是元素，但元素一定是节点。

[使用C#实现实体类和XML相互转换](https://www.cnblogs.com/dotnet261010/p/6513618.html)

[C#实体类与XML相互转换](https://my.oschina.net/u/4308373/blog/3423228)

[C# XML与实体互转，实体类反序列化属性对应转换成 XmlAttribute_qiandeqiande的专栏-CSDN博客](https://blog.csdn.net/qiandeqiande/article/details/79055187)



[广海小疯疯-C#/.NET异步编程【目录】_广海_小疯疯-CSDN博客](https://blog.csdn.net/qq_34202873/article/details/94559875)

[细说.NET中的多线程 (二 线程池)](https://www.cnblogs.com/myprogram/p/4893059.html)

https://www.cnblogs.com/hdwgxz/p/6258014.html

[.NET 实现并行的几种方式（一）](https://www.cnblogs.com/08shiyan/p/5692429.html)

[C#并行编程中的Parallel.Invoke](https://www.cnblogs.com/DomoYao/p/5088417.html)

[在 C# 异步方法中使用 out/ref 参数机制_cheer-CSDN博客](https://blog.csdn.net/cheer_cheer/article/details/52107328)

[【读书笔记】.Net并行编程(三)---并行集合 - stoneniqiu - 博客园](https://www.cnblogs.com/stoneniqiu/p/4931513.html)

[使用Parallel.Invoke并行你的代码_无风听海-CSDN博客](https://blog.csdn.net/hou478410969/article/details/7707631)

[多线程调用同一个对象的方法_多线程简介（全）_weixin_39959298的博客-CSDN博客](https://blog.csdn.net/weixin_39959298/article/details/111332405)

[.Net Core3.0 WebApi 项目框架搭建 二:API 文档神器 Swagger](https://www.cnblogs.com/huguodong/archive/2004/01/13/12897288.html)

# .net core项目，部署到Linux：时区问题

.net core项目，部署到Linux（CentOS）上的时候，发现DateTime.Now获取的时间与Windows不一致，获取到系统时间比系统的时间实际少了8个小时，发现这一个问题，大家第一时间想到的是时区差异。

具体原因就是：Linux和Windows两者所采用的时区不同，两者的时区分别为：Linux：IANA，Windows:Windows time zone IDs。这就是最终元凶啦！

找到原因后，那么该如何解决呢？方式很简单，就是两者采用同一个时区，最终统一采用IANA，在实现上可以借助第三方库：NodaTime。

时间的相关操作：

[xuyuanhong0902/XYH.Tools](https://github.com/xuyuanhong0902/XYH.Tools.git)