### 前言

使用多线程技术来保证UI线程可响应、提高服务器吞吐量、提升程序处理速度，设置任务优先级进行调度。

多线程技术只是多个线程在操作系统分配的不同时间片里执行，在线程数量超出用于处理它们的处理器数量的情况下，操作系统将定期为每个线程调度一个时间片来控制处理器，以此来模拟同时并发。

#### CPU

1. 多核心处理器（CPU）

   指在一块处理器（CPU）中含有多个处理单元，每一个处理单元它就相当于一个单核处理器（CPU）。因此，多核处理器的功能就相当于多台单核处理器电脑联机作战。

2. 超线程处理器（CPU）

   指在一块CPU中，用虚拟的方法将一个物理核心模拟成多个核心（一般情况是一个单物理核心，模拟成二个核心，也即所谓的二线程。只有当线程数比物理核心数多才能叫超线程。如四核四线程并不是超线程，而四核八线程才能叫超线程）。

3. 优缺点：
   1. 从理论上说，多核心比超线程具有更高运算能力。但多核心也有一个明显的缺点，那就是多核心的使用效率比超线程处理器（CPU）低。因为，多核心在处理数据时，它们相互“合作”的并不是很完美，常常某个核心需要等待其他核心的计算数据，从而耽误时间。另外，由于目前多核心都是采用共享缓存，这更使多核心的CPU运算速度减慢不少（因为：CPU读取Cache时是以行为单位读取的，如果两个硬件线程的两块不同内存位于同一Cache行里，那么当两个硬件线程同时在对各自的内存进行写操作时，将会造成两个硬件线程写同一Cache行的问题，它会引起竞争）。
   2. 超线程是用虚拟的方法将一个物理核心虚拟成多个核心，它能够最大限度地利用现有的核心资源，具有较高性价比。

#### 操作系统

操作系统对多核处理器的支持主要体现在调度和中断上：

1. 对任务的分配进行优化。使同一应用程序的任务尽量在同一个核上执行。

2. 对任务的共享数据优化。由于多核处理器（Chip Multi-Processor，CMP）体系结构共享缓存（目前），可以考虑改变任务在内存中的数据分布，使任务在执行时尽量增加缓存的命中率。

3. 对任务的负载均衡优化。当任务在调度时，出现了负载不均衡，考虑将较忙处理器中与其他任务最不相关的任务迁移，以达到数据的冲突最小。
4. 多任务处理的操作系统可以创建多个进程中的多个线程同时执行的效果。它通过以下方式实现这一点：在需要处理器时间的线程之间分割可用处理器时间，并轮流为每个线程分配处理器时间片。

#### 进程和线程

1. 进程

   进程是应用程序的执行实例，每个进程是由私有的虚拟地址空间、代码、数据和其它各种系统资源组成，进程在运行过程中创建的资源随着进程的终止而被销毁，所使用的系统资源在进程终止时被释放或关闭。

2. 线程

   线程是进程内部的一个执行单元。系统创建好进程后，实际上就启动执行了该进程的主执行线程。主执行线程终止了，进程也就随之终止。

   每个线程都维护异常处理程序、调度优先级和线程上下文。（线程上下文，当前执行的线程在其时间片结束时被挂起，而另一个线程继续运行。当系统从一个线程切换到另一个线程时，它将保存被抢先的线程的线程上下文，并重新加载线程队列中下一个线程的已保存线程上下文）

3. 关系

   操作系统使用进程将它们正在执行的不同应用程序分开，.NET Framework 将操作系统进程进一步细分为System.AppDomain （应用程序域）的轻量托管子进程。

   线程是CPU的调度单元，是进程中的执行单位，一个进程中可以有多个线程同时执行代码。

#### CPU的两种竞争策略

Unix系统使用的是时间片算法，而Windows则属于抢占式的。

1. 在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。

2. 所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他

### 线程

#### 属性

1) CurrentContext         获取线程正在其中执行的当前上下文。主要用于线程内部存储数据。

2) ExecutionContext       获取一个System.Threading.ExecutionContext对象，该对象包含有关当前线程的各种上下文的信息。主要用于线程间数据共享。

3) IsThreadPoolThread     获取一个值，该值指示线程是否属于托管线程池。

4) ManagedThreadId      获取一个整数，表示此托管线程的唯一标识符。

5) IsBackground           获取或设置一个值，该值指示某个线程是否为后台线程。

   前台线程和后台线程并不等同于主线程和工作线程，如果所有的前台线程终止，那所有的后台线程也会被自动终止。应用程序必须运行完所有的前台线程才可以退出，所以，要特别注意前台线程的使用，**会造成应用程序终止不了**。

   **默认情况下：通过Thread.Start()方法开启的线程都默认为前台线程**。可以设置IsBackground属性将线程配置为后台线程。

   属于托管线程池的线程（即其 IsThreadPoolThread 属性为 true 的线程）是后台线程。从非托管代码进入托管执行环境的所有线程都被标记为后台线程。

6) IsAlive     判断此线程是否还存活。经测试**只有 Unstarted、Stopped 返回false；其他线程状态都返回true**。

####  创建线程

```C#
public Thread(ParameterizedThreadStart start);
public Thread(ThreadStart start);
public Thread(ParameterizedThreadStart start, int maxStackSize);
public Thread(ThreadStart start, int maxStackSize);
```

#### 回调示例；

```C#
// 包装异步方法的委托，回调函数
public delegate void ExampleCallback(int lineCount);
// 帮助器类
public class ThreadWithState
{
    private string boilerplate;
    private int value;
    private ExampleCallback callback;
  
    public ThreadWithState(string text, int number,
        ExampleCallback callbackDelegate)
 
    {
        boilerplate = text;
        value = number;
        callback = callbackDelegate;
    }
 
    public void ThreadProc()
    {
        Console.WriteLine(boilerplate, value);
        // 异步执行完时调用回调
        if (callback != null)
            callback(1);
    }
}
  
    // 异步调用
    // 将需传递给异步执行方法数据及委托传递给帮助器类
    ThreadWithState tws = new ThreadWithState(
       "This report displays the number {0}.",
       42,
       new ExampleCallback(ResultCallback)
    );
    Thread t = new Thread(new ThreadStart(tws.ThreadProc));
    t.Start();
```

#### 调度线程

使用Thread.Priority属性获取或设置任何线程的优先级。

优先级：Lowest <BelowNormal< Normal <AboveNormal< Highest

每个线程都具有分配给它的线程优先级。在公共语言运行库中创建的线程最初分配的优先级为ThreadPriority.Normal。在运行库外创建的线程会保留它们在进入托管环境之前所具有的优先级。

线程是根据其优先级而调度执行的。所有线程都是由操作系统分配处理器时间片的，如果具有相同优先级的多个线程都可用，则计划程序将遍历处于该优先级的线程，并为每个线程提供一个“固定的时间片”来执行，执行完“固定的时间片”后就切换线程，若当前任务还未执行完，则必须等待下一次的调度。

**低优先级的线程并不是被阻塞直到较高优先级的线程完成，低优先级的线程只是在相同时间间隔被CPU调度的次数相对较少。**

重要提示：

​     最好是降低一个线程的优先级，而不是提升另一个线程的优先级。如果线程要执行一个**长时间运行**的计算限制任务，比如编译代码、拼写检查、电子表格重新计算等，一般应降低该线程的优先级。如果线程要快速响应某个事件，然后**运行非常短暂的时间**，再恢复为等待状态，则应提高该线程的优先级。高优先级线程在其生命中的大多数时间里都应处于等待状态，这样才不至于影响系统的总体响应能力。

#### 单元状态

```C#
public enum ApartmentState
{
    // System.Threading.Thread 将创建并进入一个单线程单元。
    STA = 0,
    // System.Threading.Thread 将创建并进入一个多线程单元。
    MTA = 1,
    // 尚未设置 System.Threading.Thread.ApartmentState 属性。
    Unknown = 2,
}
```

如果在启动线程之前未设置单元状态，则该线程被初始化为默认多线程单元 (MTA)。（终结器线程和由ThreadPool控制的所有线程都是 MTA）

要将主应用程序线程的单元状态设置为ApartmentState.STA的唯一方法是将STAThreadAttribute属性应用到入口点方法。（eg：Main()方法）

#### 线程状态

线程可以同时处于多个状态中。例如，如果某个线程在 Monitor.Wait 调用被阻止，并且另一个线程对同一个线程调用 Abort，则该线程将同时处于 WaitSleepJoin 和 AbortRequested 状态。在这种情况下，一旦该线程从对 Wait 的调用返回或该线程中断，它就会收到 ThreadAbortException

```C#
public enum ThreadState
{
    //线程已启动，它未被阻塞，并且没有挂起的 ThreadAbortException。
    Running = 0,
    // 正在请求线程停止。 这仅用于内部。
    StopRequested = 1,
    // 正在请求线程挂起。
    SuspendRequested = 2,
    // 线程正作为后台线程执行（相对于前台线程而言）。 此状态可以通过设置 Thread.IsBackground 属性来控制。
    Background = 4,
    // 尚未对线程调用 Thread.Start() 方法。
    Unstarted = 8,
    // 线程已停止。
    Stopped = 16,
    // 线程已被阻止。 这可能是因为：
    //调用 Thread.Sleep(System.Int32) 或 Thread.Join()、
    //请求锁定（例如通过调用Monitor.Enter(System.Object) 
    //或 Monitor.Wait(System.Object,System.Int32,System.Boolean)）
    //或等待线程同步对象（例如Threading.ManualResetEvent）。
    WaitSleepJoin = 32,
    // 线程已挂起。
    Suspended = 64,
    // 已对线程调用了 Thread.Abort(System.Object) 方法，但线程尚未收到试图终止它的挂起的ThreadAbortException。
    AbortRequested = 128,
    // 线程状态包括 ThreadState.AbortRequested 并且该线程现在已死，但其状态尚未更改为 ThreadState.Stopped。
    Aborted = 256,
}
```

#### 状态操作方法

| 操作                                                 | 所得到的新状态         |
| ---------------------------------------------------- | ---------------------- |
| 调用 Thread 类的构造函数。                           | Unstarted              |
| 另一个线程调用 Thread.Start。                        | Unstarted              |
| 线程响应 Thread.Start 并开始运行。                   | Running                |
| 线程调用 Thread.Sleep。                              | WaitSleepJoin          |
| 线程对另一个对象调用 Monitor.Wait。                  | WaitSleepJoin          |
| 线程对另一个线程调用 Thread.Join。                   | WaitSleepJoin          |
| 另一个线程调用 Thread.Suspend。                      | SuspendRequested       |
| 线程返回到托管代码时，线程响应 Thread.Suspend 请求。 | Suspended              |
| 另一个线程调用 Thread.Resume。                       | Running                |
| 另一个线程调用 Thread.Abort。                        | AbortRequested         |
| 线程返回到托管代码时，线程响应 Thread.Abort。        | Aborted ，然后 Stopped |

![clip_image002](images/201212161937425842.jpg)

线程销毁及取消销毁:

```C#
Thread t = new Thread(() =>
      {
          try
          {
              Console.WriteLine("1.try内部，调用Abort前。");
              // ……等待其他线程调用该线程的Abort()
              Thread.Sleep(1000);
              Console.WriteLine("try内部，调用Abort后。");
          }
          catch (ThreadAbortException abortEx)
          {
              Console.WriteLine("3.catch:" + abortEx.GetType());
              // 在catch中调用了ResetAbort，则try块外面的代码依旧执行，即：线程没有终止.
              Thread.ResetAbort();
              Console.WriteLine("4.catch：调用ResetAbort()。");
          }
          finally
          {
              Console.WriteLine("5.finally");
              // 在finally中调用Thread.ResetAbort()不能取消线程的销毁
              // Thread.ResetAbort();
          }
          Console.WriteLine("6.try外面，调用Abort后。");
      }
 
 // 其他线程调用该线程的Abort()
 t.Abort(); 
 Console.WriteLine("2.主线程，调用Abort。");
```

Sleep()方法使当前线程放弃剩余时间片，立即挂起(阻塞)并且在指定时间内不被调度。**直到其他运行线程调用 Interrupt ()中断处于WaitSleepJoin线程状态的线程，或调用Abort()中止线程。**

Join()，在线程A中调用线程B的Join()实例方法。在继续执行标准的 COM 和 SendMessage 消息泵处理期间，线程A将被阻塞，直到线程B终止为止。

Interrupt()，中断处于WaitSleepJoin线程状态的线程。如果此线程当前未阻塞在等待、休眠或联接状态中，则下次开始阻塞时它将被中断并引发ThreadInterruptedException异常。

Suspend()与Resume()来挂起和唤醒线程，这两方法已过时

#### 原子操作

1) Thread.MemoryBarrier()、

   按如下方式同步内存存取：执行当前线程的处理器在对指令重新排序时，不能采用先执行 Thread.MemoryBarrier()调用之后的内存存取，再执行 Thread.MemoryBarrier() 调用之前的内存存取的方式。

2) Thread.VolatileRead()+Thread.VolatileWrite()  （内部使用MemoryBarrier()内存屏障）

   a)     VolatileRead()      读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值。

   b)     VolatileWrite ()     立即向字段写入一个值，以使该值对计算机中的所有处理器都可见。

3) 关键字Volatile：

   为了简化编程，C#编译器提供了volatile关键字。确保JIT编译器对易失字段都以易失读取或者易失写入的方法执行，不用显示调用Thread的VolatileRead()和VolatileWrite()。

#### 线程本地存储区

线程使用托管线程本地存储区 (TLS，Thread-Local Storage)和线程相关的静态字段来存储线程特定的数据，托管 TLS 中的数据都是线程和应用程序域组合所独有的，其他任何线程（即使是子线程）都无法获取这些数据。

```C#
/// <summary>
/// 数据槽  的使用示例
/// </summary>
private static void TLS4DataSlot()
{
    LocalDataStoreSlot slot = Thread.AllocateNamedDataSlot("Name");
    Console.WriteLine(String.Format("ID为{0}的线程，命名为\"Name\"的数据槽，开始设置数据。", Thread.CurrentThread.ManagedThreadId));
    Thread.SetData(slot, "小丽");
    Console.WriteLine(String.Format("ID为{0}的线程，命名为\"Name\"的数据槽，数据是\"{1}\"。", Thread.CurrentThread.ManagedThreadId, Thread.GetData(slot)));
 
    Thread newThread = new Thread(
        () =>
        {
            LocalDataStoreSlot storeSlot = Thread.GetNamedDataSlot("Name");
            Console.WriteLine(String.Format("ID为{0}的线程，命名为\"Name\"的数据槽，在新线程为其设置数据 前 为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, Thread.GetData(storeSlot)));
            Console.WriteLine(String.Format("ID为{0}的线程，命名为\"Name\"的数据槽，开始设置数据。", Thread.CurrentThread.ManagedThreadId));
            Thread.SetData(storeSlot, "小红");
            Console.WriteLine(String.Format("ID为{0}的线程，命名为\"Name\"的数据槽，在新线程为其设置数据 后 为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, Thread.GetData(storeSlot)));
 
         // 命名数据槽中分配的数据必须用 FreeNamedDataSlot() 释放。未命名的数据槽数据随线程的销毁而释放
            Thread.FreeNamedDataSlot("Name");
        }
    );
    newThread.Start();
    newThread.Join();
 
    Console.WriteLine(String.Format("执行完新线程后，ID为{0}的线程，命名为\"Name\"的数据槽，在新线程为其设置数据 后 为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, Thread.GetData(slot)));
}
```

命名槽可能很方便，因为您可以在需要它时通过将其名称传递给 GetNamedDataSlot 方法来检索该槽，而不是维护对未命名槽的引用。但是，如果另一个组件使用相同的名称来命名其线程相关的存储区，并且有一个线程同时执行来自您的组件和该组件的代码，则这两个组件可能会破坏彼此的数据。（本方案假定这两个组件在同一应用程序域内运行，并且它们并不用于共享相同数据。）

为了获得更好的性能，请改用以 System.ThreadStaticAttribute特性标记的线程相关的静态字段。

某类型的字段【总是某个线程和应用程序域组合】所独有的（即不是共享的），则使用ThreadStaticAttribute修饰静态字段(static)。

```C#
// 不应依赖于类构造函数来初始化线程相关的静态字段[ThreadStatic]
[ThreadStatic]
static string name = String.Empty;
/// <summary>
/// 线程相关静态字段  的使用示例
/// </summary>
private static void TLS4StaticField()
{
    Console.WriteLine(String.Format("ID为{0}的线程，开始为name静态字段设置数据。", Thread.CurrentThread.ManagedThreadId));
    name = "小丽";
    Console.WriteLine(String.Format("ID为{0}的线程，name静态字段数据为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, name));
 
    Thread newThread = new Thread(
        () =>
        {
            Console.WriteLine(String.Format("ID为{0}的线程，为name静态字段设置数据 前 为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, name));
            Console.WriteLine(String.Format("ID为{0}的线程，开始为name静态字段设置数据。", Thread.CurrentThread.ManagedThreadId));
            name = "小红";
            Console.WriteLine(String.Format("ID为{0}的线程，为name静态字段设置数据 后 为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, name));
        }
    );
    newThread.Start();
    newThread.Join();
 
    Console.WriteLine(String.Format("执行完新线程后，ID为{0}的线程，name静态字段数据为\"{1}\"。", Thread.CurrentThread.ManagedThreadId, name));
}
```

### 线程池

“池”是一种“以空间换时间”的做法，我们在内存中保存一系列整装待命的对象，供人随时差遣。与系统效率相比，这些对象所占用的内存空间太微不足道了。

#### 对象池

对于对象池的清理通常设计两种方式：

1) 手动清理，即主动调用清理的方法。

2) 自动清理，即通过System.Threading.Timer来实现定时清理。

```C#
public sealed class ObjectPool<T> where T : ICacheObjectProxy<T>
{
    // 最大容量
    private Int32 m_maxPoolCount = 30;
    // 最小容量
    private Int32 m_minPoolCount = 5;
    // 已存容量
    private Int32 m_currentCount;
    // 空闲+被用 对象列表
    private Hashtable m_listObjects;
    // 最大空闲时间
    private int maxIdleTime = 120;
    // 定时清理对象池对象
    private Timer timer = null;
 
    /// <summary>
    /// 创建对象池
    /// </summary>
    /// <param name="maxPoolCount">最小容量</param>
    /// <param name="minPoolCount">最大容量</param>
    /// <param name="create_params">待创建的实际对象的参数</param>
    public ObjectPool(Int32 maxPoolCount, Int32 minPoolCount, Object[] create_params){ }
 
    /// <summary>
    /// 获取一个对象实例
    /// </summary>
    /// <returns>返回内部实际对象，若返回null则线程池已满</returns>
    public T GetOne(){ }
 
    /// <summary>
    /// 释放该对象池
    /// </summary>
    public void Dispose(){ }
 
    /// <summary>
    /// 将对象池中指定的对象重置并设置为空闲状态
    /// </summary>
    public void ReturnOne(T obj){ }
 
    /// <summary>
    /// 手动清理对象池
    /// </summary>
    public void ManualReleaseObject(){ }
 
    /// <summary>
    /// 自动清理对象池（对大于 最小容量 的空闲对象进行释放）
    /// </summary>
    private void AutoReleaseObject(Object obj){ }
}
```

#### 线程池

ThreadPool静态类，为应用程序提供一个由系统管理的辅助线程池，从而使您可以集中精力于应用程序任务而不是线程管理。每个进程都有一个线程池,一个Process中只能有一个实例，它在各个应用程序域（AppDomain）是共享的。

在内部，线程池将自己的线程划分工作者线程(辅助线程)和I/O线程。前者用于执行普通的操作，后者专用于异步IO，比如文件和网络请求。

```C#
public static class ThreadPool
{
    // 将操作系统句柄绑定到System.Threading.ThreadPool。
    public static bool BindHandle(SafeHandle osHandle);
 
    // 检索由ThreadPool.GetMaxThreads(Int32,Int32)方法返回的最大线程池线程数和当前活动线程数之间的差值。
    // 参数workerThreads指工作者线程；参数completionPortThreads指异步 I/O 线程。
    public static void GetAvailableThreads(out int workerThreads
            , out int completionPortThreads);
 
    // 设置和检索可以同时处于活动状态的线程池请求的数目。
    // 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(out int workerThreads, out int completionPortThreads);
    // 设置和检索线程池在新请求预测中维护的空闲线程数。
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(out int workerThreads, out int completionPortThreads);
 
    // 将方法排入队列以便执行，并指定包含该方法所用数据的对象。此方法在有线程池线程变得可用时执行。
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    // 将重叠的 I/O 操作排队以便执行。如果成功地将此操作排队到 I/O 完成端口，则为 true；否则为 false。
    // 参数overlapped:要排队的System.Threading.NativeOverlapped结构。
    public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    // 将指定的委托排队到线程池，但不会将调用堆栈传播到工作者线程。
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
 
    // 注册一个等待Threading.WaitHandle的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。
    // executeOnlyOnce如果为 true，表示在调用了委托后，线程将不再在waitObject参数上等待；
    // 如果为 false，表示每次完成等待操作后都重置计时器，直到注销等待。
    public static RegisteredWaitHandle RegisterWaitForSingleObject(
            WaitHandle waitObject
            , WaitOrTimerCallback callBack, object state, 
            Int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(
              WaitHandle waitObject
            , WaitOrTimerCallback callBack
            , object state
            , int millisecondsTimeOutInterval
            , bool executeOnlyOnce);
    ……
}
```

1. 使用GetMaxThreads()和SetMaxThreads()获取和设置最大线程数
2. 使用GetMinThreads()和SetMinThreads()获取和设置最小空闲线程数
3. 通过静态方法GetAvailableThreads()返回的线程池线程的最大数目和当前活动数目之间的差值，即获取线程池中当前可用的线程数目

### 执行上下文

ExecutionContext  获取一个System.Threading.ExecutionContext对象，该对象包含有关当前线程的各种上下文的信息。主要用于线程间数据共享。

```C#
public sealed class ExecutionContext : IDisposable, ISerializable
{
    public void Dispose();
    public void GetObjectData(SerializationInfo info, StreamingContext context);
 
    // 此方法对于将执行上下文从一个线程传播到另一个线程非常有用。
    public ExecutionContext CreateCopy();
    // 从当前线程捕获执行上下文的一个副本。
    public static ExecutionContext Capture();
    // 在当前线程上的指定执行上下文中运行某个方法。
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
 
    // 取消执行上下文在异步线程之间的流动。
    public static AsyncFlowControl SuppressFlow();
    public static bool IsFlowSuppressed();
    // RestoreFlow  撤消以前的 SuppressFlow 方法调用的影响。
    // 此方法由 SuppressFlow 方法返回的 AsyncFlowControl 结构的 Undo 方法调用。
    // 应使用 Undo 方法（而不是 RestoreFlow 方法）恢复执行上下文的流动。
    public static void RestoreFlow();
}
```

ExecutionContext 类提供的功能让用户代码可以在用户定义的异步点之间捕获和传输此上下文。公共语言运行时(CLR)确保在托管进程内运行时定义的异步点之间一致地传输 ExecutionContext。

每当一个线程(初始线程)使用另一个线程(辅助线程)执行任务时，CLR会将前者的执行上下文流向（复制到）辅助线程（注意这个自动流向是单方向的）。这就确保了辅助线程执行的任何操作使用的是相同的安全设置和宿主设置。还确保了初始线程的逻辑调用上下文可以在辅助线程中使用。

但执行上下文的复制会造成一定的性能影响。因为执行上下文中包含大量信息，而收集所有这些信息，再把它们复制到辅助线程，要耗费不少时间。如果辅助线程又采用了更多地辅助线程，还必须创建和初始化更多的执行上下文数据结构。

所以，为了提升应用程序性能，我们可以阻止执行上下文的流动。当然这只有在辅助线程不需要或者不访问上下文信息的时候才能进行阻止。

下面给出一个示例为了演示：

1) 在线程间共享逻辑调用上下文数据（CallContext）。

2) 为了提升性能，阻止\恢复执行上下文的流动。

3) 在当前线程上的指定执行上下文中运行某个方法。

```C#
private static void Example_ExecutionContext()
{
    CallContext.LogicalSetData("Name", "小红");
    Console.WriteLine("主线程中Name为：{0}", CallContext.LogicalGetData("Name"));
 
    // 1)   在线程间共享逻辑调用上下文数据（CallContext）。
    Console.WriteLine("1)在线程间共享逻辑调用上下文数据（CallContext）。");
    ThreadPool.QueueUserWorkItem((Object obj) 
        => Console.WriteLine("ThreadPool线程中Name为：\"{0}\"", CallContext.LogicalGetData("Name")));
    Thread.Sleep(500);
    Console.WriteLine();
    // 2)   为了提升性能，取消\恢复执行上下文的流动。
    ThreadPool.UnsafeQueueUserWorkItem((Object obj)
        => Console.WriteLine("ThreadPool线程使用Unsafe异步执行方法来取消执行上下文的流动。Name为：\"{0}\""
        , CallContext.LogicalGetData("Name")), null);
    Console.WriteLine("2)为了提升性能，取消/恢复执行上下文的流动。");
    AsyncFlowControl flowControl = ExecutionContext.SuppressFlow();
    ThreadPool.QueueUserWorkItem((Object obj) 
        => Console.WriteLine("(取消ExecutionContext流动)ThreadPool线程中Name为：\"{0}\"", CallContext.LogicalGetData("Name")));
    Thread.Sleep(500);
    // 恢复不推荐使用ExecutionContext.RestoreFlow()
    flowControl.Undo();
    ThreadPool.QueueUserWorkItem((Object obj) 
        => Console.WriteLine("(恢复ExecutionContext流动)ThreadPool线程中Name为：\"{0}\"", CallContext.LogicalGetData("Name")));
    Thread.Sleep(500);
    Console.WriteLine();
    // 3)   在当前线程上的指定执行上下文中运行某个方法。(通过获取调用上下文数据验证)
    Console.WriteLine("3)在当前线程上的指定执行上下文中运行某个方法。(通过获取调用上下文数据验证)");
    ExecutionContext curExecutionContext = ExecutionContext.Capture();
    ExecutionContext.SuppressFlow();
    ThreadPool.QueueUserWorkItem(
        (Object obj) =>
        {
            ExecutionContext innerExecutionContext = obj as ExecutionContext;
            ExecutionContext.Run(innerExecutionContext, (Object state) 
                => Console.WriteLine("ThreadPool线程中Name为：\"{0}\""<br>                       , CallContext.LogicalGetData("Name")), null);
        }
        , curExecutionContext
     );
}
```

### 思考问题

在以下几种情况下，适合于创建并管理自己的线程而不是使用线程池线程：

1. 需要前台线程。**(线程池线程“始终”是后台线程)**

2. 需要使线程具有特定的优先级。**(****线程池线程都是默认优先级，“不建议”进行修改)**

3. 任务会长时间占用线程。由于线程池具有最大线程数限制，因此大量占用线程池线程可能会阻止任务启动。

4. 需要将线程放入单线程单元(STA)。**(所有ThreadPool线程“始终”是多线程单元(MTA)中)**

5. 需要具有与线程关联的稳定标识，或使某一线程专用于某一任务。

判断多个线程是否都结束的几种方法：

1.  线程计数器，使用原子操作(eg：Volatile、InterLocked)同步这个计数器变量
2. 使用Thread.join方法，join方法只有在线程结束时才继续执行下面的语句。
3.  轮询Thread的IsAlive属性，IsAlive判断此线程是否还存活。经测试只有 Unstarted、Stopped 返回false；其他线程状态都返回true
4.  使用回调函数进行通知
5. 使用同步基元对象