### 问题

**为什么不把所有接口的泛型参数都自动变成可变的？对于可变的泛型参数，又为什么要区分为协变和逆变**？我们可以把这个问题分解成3个具体的子问题：

  1. 为什么 IComparable<in T> 被声明成可变的而 IEquatable<T> 却被声明成不可变的？

     IComparable 支持逆变, 因为子类实现了自己的IComparable<Student>接口, 可以隐式转换为父类实现的接口IComparable<Person>.  见代码: **GenericsConvariance.cs**

     IEquatable<T> 不支持逆变, 因为IEquatable<T> 的设计者认为**判断不同类型的对象是否相等的方法都应该是不同的**，也就是说，他鼓励我们为每个类型实现一个 Equals() 方法.

  2. 为什么 IList<T> 被声明为不可变的？

     既然协变的接口的泛型参数只能作为函数的返回值，而逆变的接口的泛型参数只能作为函数的参数，那么像 IList<T> 这种 T 既要做为返回值又要作为参数的情况，自然只能声明为不可变的了

  3. 为什么一个泛型参数不可以即是协变的又是逆变的？

     为了在编译期进行类型安全检查。

     只有子类型到父类型的隐式转换是类型安全的。例如下面的语句是类型安全的：

     ```c#
     Student jcl = new Student { Name = "Jing", Grade = 2 };  
     Person p = jcl; // 子类向父类的隐式转换是安全的
       
     Person p = new Person { Name = "aa" };
     Student jcl = p; // 父类向子类的类型转换是不安全的, 无法通过编译
     
     //父类转换成子类，可以使用显式的向下转型操作
     Student jcl = p as Student; // 如果转型失败，jcl 将会是 null
     ```

     虽然编译器允许我们做这种显式向下转型操作绕过编译期类型检查，但是大多数情况下我们喜欢并且依赖着编译期类型检查。当语言支持泛型接口间的隐式转换时，我们同样希望编译器能为我们做类型安全检查。
     设想一下，如果不必区分协变和逆变，只要我们想声明可变的泛型接口，直接就用加上一个 var 关键字

     ```C#
     // 伪代码
     public interface ISomeInterface<var T>
     {
         T GetAnItem();
         void SetAnItem(T v);
     }
     
     ISomeInterface<Student> istu = null;
     ISomeInterface<Person> iperson = null;
     iperson = istu;
     Person p = iperson.GetAnItem(); // 将一个 Student 对象赋值给一个 Person 类型的变量，没问题
     iperson.SetAnItem(new Person()); // 将一个 Person  对象赋值给一个 Student 类型的变量，不安全！
     
     //反之，如果我们这样使用它：
     ISomeInterface<Student> istu = null;
     ISomeInterface<Person> iperson = null;
     istu = iperson;
     Student s = istu.GetAnItem(); // 将一个 Person 对象赋值给一个 Student 类型的变量，不安全！
     istu.SetAnItem(new Student()); // 将一个 Student 对象赋值给一个 Person 类型的变量，没问题
     ```

### 小结

1. 类型间的安全的隐式转换是单向的（譬如由子类向父类转换时），泛型接口（作为类型的一种）间安全的类型转换也必然是**单向**的。
2. 泛型接口间的类型转换有**两个方向**，
   1. 一是只允许 ISomeInterface<子类型> 到 ISomeInterface<父类型> 的隐式转换，这时我们说这个泛型接口是协变的；
   2. 一是只允许 ISomeInterface<父类型> 到 ISomeInterface<子类型> 的隐式转换，这时我们说这个泛型接口是逆变的。
3. 在多数情况下（不考虑函数的返回值或参数是另一个泛型接口或委托的情况），协变的泛型参数只允许作为**输出**的对象的类型，逆变的泛型参数只允许作为**输入**的对象的类型，这也是关键字被定为“out” 和 “in” 的原因。

假设我们分别定义了一个协变的接口 ICovariantDemo<out T> 和一个逆变的接口 IContravarianceDemo<in T>，下图可以让我们有更加直观的感受：

![img](https://pic002.cnblogs.com/images/2010/25284/2010092323400655.png)

### 复合的情况



### 参考

https://www.cnblogs.com/1-2-3/archive/2010/09/27/covariance-contravariance-csharp4.html

