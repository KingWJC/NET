可以使用ThreadPool的QueueUserWorkItem方法来发起一次简单的异步操作。然而，这个技术存在许多限制。最大的问题是没有一个内建的机制让你知道操作在什么时候完成，也没有一个机制在操作完成时获得一个返回值。为了克服这些限制（并解决其他一些问题），Microsoft引入了三种异步编程模式

1. .NET1.0异步编程模型 (APM)，基于IAsyncResult接口实现。

2. .NET2.0基于事件的异步编程模式(EMP)

3. .NET4.X[基于任务的异步编程模式(TPL)

### APM

使用IAsyncResult设计模式的异步操作是通过Begin\*** 开启操作并返回IAsyncResult对象，使用 End\*** 方法来结束操作，通过回调方法来做异步操作后其它事项。

#### BeginInvoke 方法：

1. 方法带有该方法的同步版本签名中声明的任何参数。

2. 方法签名中不包含任何输出参数。方法签名最后两个参数的规范是：

   第一个参数定义一个AsyncCallback委托，此委托引用在**异步操作完成时**调用的方法。

   第二个参数是一个用户定义的对象。此对象可用来向异步操作完成时为AsyncCallback委托方法传递应用程序特定的状态信息（eg：可通过此对象在委托中访问End*** 方法)。

   另外，这两个参数都可以传递null。

3. 返回IAsyncResult对象。

   ```C#
   // 表示异步操作的状态。
   [ComVisible(true)]
   public interface IAsyncResult
   {
       // 获取用户定义的对象，它限定或包含关于异步操作的信息。
       object AsyncState { get; }
       // 获取用于等待异步操作完成的System.Threading.WaitHandle，待异步操作完成时获得信号。
       WaitHandle AsyncWaitHandle { get; }
       // 获取一个值，该值指示异步操作是否同步完成。
       bool CompletedSynchronously { get; }
       // 获取一个值，该值指示异步操作是否已完成。
       bool IsCompleted { get; }
   }
    
   // 常用委托声明（我后面示例是使用了自定义的带ref参数的委托）
   public delegate void AsyncCallback(IAsyncResult ar)
   ```

#### EndInvoke 方法：

1. 方法可结束异步操作，如果调用EndInvoke  时，IAsyncResult对象表示的异步操作还未完成，则 EndInvoke  将在异步操作完成之前阻塞调用线程。

2. EndInvoke 方法的返回值与其同步副本的返回值类型相同。EndInvoke 方法带有该方法同步版本的签名中声明的所有out 和 ref 参数以及由BeginInvoke返回的IAsyncResult，规范上 IAsyncResult 参数放最后。

   1. 要想获得返回结果，必须调用的方法;

   2. 若带有out 和 ref 参数，实现上委托也要带有out 和 ref 参数，以便在回调中获得对应引用传参值做相应逻辑;.

3. 总是调用EndInvoke () 方法，而且只调用一次

#### I/O限制

以下理由都是针对“I/O限制”的异步操作提出。

然而，对于计算限制的异步操作，尽管都是用户代码，但还是推荐遵守此规则。

I/O限制的异步操作：比如像带FileOptions.Asynchronous标识的FileStream，其BeginRead()方法向Windows发送一个I/O请求包（I/O Request Packet，IRP）后方法不会阻塞线程而是立即返回，由Windows将IRP传送给适当的设备驱动程序，IRP中包含了为BeginRead()方法传入的回调函数，待硬件设备处理好IRP后，会将IRP的委托排队到CLR的线程池队列中。

1. 必须调用End方法，否则会造成资源的泄露。有的开发人员写代码调用Begin方法异步执行I/O限制后就不需要进行任何处理了，所以他们不关心End方法的调用。但是，出于以下两个原因，End方法是必须调用的：

   a)     在异步操作时，对于I/O限制操作，CLR会分配一些内部资源，操作完成时，CLR继续保留这些资源直至End方法被调用。如果一直不调用End，这些资源会直到进程终止时才会被回收。（End方法设计中常常包含资源释放）

   b)     发起一个异步操作时，实际上并不知道该操作最终是成功还是失败（因为操作由硬件在执行）。要知道这一点，只能通过调用End***方法，检查它的返回值或者看它是否抛出异常。

2. 另外，需要注意的是I/O限制的异步操作完全不支持取消（因为操作由硬件执行），但可以设置一个标识，在完成时丢弃结果来模拟取消行为。

#### 应用

1. 基于IAsyncResult构造一个异步API，实现带ref引用参数的异步操作

   包含**三种阻塞式响应异步调用**和**一种无阻塞式委托响应异步调用**

2. 使用委托进行异步编程

   对于委托，编译器会为我们生成同步调用方法“invoke”以及异步调用方法“BeginInvoke”和“EndInvoke”

   异步委托是快速为方法构建异步调用的方式，它基于IAsyncResult设计模式实现的异步调用，即，通过BeginInvoke返回IAsyncResult对象；通过EndInvoke获取结果值

#### 问题

没有提供进度通知等功能及多线程间控件的访问。

### EAP

基于事件的异步编程模式(EAP，Event-based Asynchronous Pattern)。

#### 功能实现

通过事件、AsyncOperationManager类和AsyncOperation类两个帮助器类实现如下功能：

1) 异步执行耗时的任务。

2) 获得进度报告和增量结果。

3) 支持耗时任务的取消。

4) 获得任务的结果值或异常信息。

5) 更复杂：支持同时执行多个异步操作、进度报告、增量结果、取消操作、返回结果值或异常信息。

对于相对简单的多线程应用程序，BackgroundWorker组件提供了一个简单的解决方案。对于更复杂的异步应用程序，可以考虑实现一个符合基于事件的异步模式的类。

#### 优点

EAP是为Windows窗体开发人员创建的，其主要优点在于：

1. EAP与Microsoft Visual Studio UI设计器进行了很好的集成。也就是说，可将大多数实现了EAP的类拖放到一个Visual Studio设计器平面上，然后双击事件名，让Visual Studio自动生成事件回调方法，并将方法同事件关联起来。

2. EAP类在内部通过SynchronizationContext类，将应用程序模型映射到合适线程处理模型，以方便跨线程操作控件。

#### AsyncOperationManager和AsyncOperation



### 多线程操作控件

访问 Windows 窗体控件本质上不是线程安全的。如果有两个或多个线程操作某一控件的状态，则可能会迫使该控件进入一种不一致的状态。还可能出现其他与线程相关的 bug，包括争用情况和死锁。确保以线程安全方式访问控件非常重要。

1. 非安全方式访问控件（此方式请永远不要再使用）

   多线程访问窗口中的控件，可以在窗口的构造函数中将Form的CheckForIllegalCrossThreadCalls静态属性设置为false。

   ```C#
   // 获取或设置一个值，该值指示是否捕获对错误线程的调用，
   // 这些调用在调试应用程序时访问控件的System.Windows.Forms.Control.Handle属性。
   // 如果捕获了对错误线程的调用，则为 true；否则为 false。
   public static bool CheckForIllegalCrossThreadCalls { get; set; }
   ```

2. 安全方式访问控件

   原理：从一个线程封送调用并跨线程边界将其发送到另一个线程，并将调用插入到创建控件线程的消息队列中,当控件创建线程处理这个消息时,就会在自己的上下文中执行传入的方法。（此过程只有调用线程和创建控件线程，并没有创建新线程）

   注意：从一个线程封送调用并跨线程边界将其发送到另一个线程会耗费大量的系统资源，所以应避免重复调用其他线程上的控件。

   1) 使用BackgroundWork后台辅助线程控件方式（详见：[基于事件的异步编程模式(EMP)](http://www.cnblogs.com/heyuquan/archive/2013/04/01/2993085.html)）。

   2) 结合TaskScheduler.FromCurrentSynchronizationContext() 和Task 实现。

   3) 捕获线程上下文ExecuteContext，并调用ExeceteContext.Run()静态方法在指定的线程上下文中执行。（详见：[执行上下文](http://www.cnblogs.com/heyuquan/archive/2012/12/23/2830214.html#context)）

   4) 使用Control类上提供的Invoke 和BeginInvoke方法。 

   5) 在WPF应用程序中可以通过WPF提供的Dispatcher对象提供的Invoke方法、BeginInvoke方法来完成跨线程工作。

#### APM方式

Invoke 和BeginInvoke跨线程访问控件方式：

Control类实现了ISynchronizeInvoke接口，提供了Invoke和BeginInvoke方法来支持其它线程更新GUI界面控件的机制。

```C#
public interface ISynchronizeInvoke
{
    // 获取一个值，该值指示调用线程是否与控件的创建线程相同。
    bool InvokeRequired { get; }
    // 在控件创建的线程上异步执行指定委托。
    AsyncResult BeginInvoke(Delegate method, params object[] args);
    object EndInvoke(IAsyncResult asyncResult);
    // 在控件创建的线程上同步执行指定委托。
    object Invoke(Delegate method, params object[] args);
}
```

1. Control类的 Invoke,BeginInvoke 内部实现如下:

   a)     Invoke   同步调用）先判断控件创建线程与当前线程是否相同，相同则直接调用委托方法；否则使用Win32API的PostMessage 异步执行,但是 Invoke 内部会调用IAsyncResult.AsyncWaitHandle等待执行完成。

   b)     BeginInvoke  （异步调用）使用Win32API的PostMessage 异步执行，并且返回 IAsyncResult 对象。

   ```C#
   UnsafeNativeMethods.PostMessage(new HandleRef(this, this.Handle)
                     , threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);
   [DllImport("user32.dll", CharSet=CharSet.Auto)]
   public static extern bool PostMessage(HandleRefhwnd, intmsg, IntPtrwparam, IntPtrlparam);
   ```

   PostMessage 是windows api，用来把一个消息发送到一个窗口的消息队列。这个方法是异步的，也就是该方法封送完毕后马上返回，不会等待委托方法的执行结束，调用者线程将不会被阻塞。（对应同步方法的windows api是：SendMessage()；消息队列里的消息通过调用GetMessage和PeekMessage取得）

2) InvokeRequired

   获取一个值，该值指示调用线程是否与控件的创建线程相同。内部关键如下：

   ```C#
   // 返回“通过GetWindowThreadProcessId功能函数得到创建指定窗口线程的标识和创建窗口的进程的标识符与当前线程Id进行比较”的结果。
   Int windowThreadProcessId = SafeNativeMethods.GetWindowThreadProcessId(ref2, out num);
   Int currentThreadId = SafeNativeMethods.GetCurrentThreadId();
   return (windowThreadProcessId != currentThreadId);
   ```

3. 示例

   ```C#
   private void InvokeControl(object mainThreadId)
   {
       if (this.InvokeRequired)
       {
           this.Invoke(new Action<String>(ChangeText), "InvokeRequired = true.改变控件Text值");
           //this.textBox1.Invoke(new Action<int>(InvokeCount), (int)mainThreadId);
       }
       else
       {
           ChangeText("在创建控件的线程上，改变控件Text值");
       }
   }
    
   private void ChangeText(String str)
   {
       this.textBox1.Text += str;
   }
   ```

   在InvokeControl方法中使用 this.Invoke(Delegate del) 和使用 this.textBox1.Invoke(Delegate del) 效果是一样的。因为在执行Invoke或BeginInvoke时，内部首先调用 FindMarshalingControl() 进行一个循环向上回溯，从当前控件开始回溯父控件，直到找到最顶级的父控件，用它作为封送对象。也就是说 this.textBox1.Invoke(Delegate del) 会追溯到和 this.Invoke(Delegate del) 一样的起点。

   子控件的创建线程一定是创建父控件的线程，所以这种追溯不会导致将调用封送到错误的目的线程。

4. 异常信息："在创建**窗口句柄**之前,不能在控件上调用 Invoke 或 BeginInvoke"

   a)     可能是在窗体还未构造完成时，在构造函数中异步去调用了Invoke 或BeginInvoke；

   b)     可能是使用辅助线程创建一个窗口并用Application.Run()去创建句柄，在句柄未创建好之前调用了Invoke 或BeginInvoke。（此时新建的窗口相当于开了另一个进程，并且为新窗口关联的辅助线程开启了消息循环机制），类似下面代码：

   ```C#
   new Thread((ThreadStart)delegate
       {
           WaitBeforeLogin = new Form2();
           Application.Run(WaitBeforeLogin);
       }).Start();
   
   // 解决方案
   // 获取一个值，该值指示控件是否有与它关联的句柄。
   public bool IsHandleCreated { get; }
   while (!this.IsHandleCreated) { …… }
   ```

