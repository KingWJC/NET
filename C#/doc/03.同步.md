### 同步的问题

在并发环境里，当同时对其共享资源进行访问时，可能造成资源损坏。需要对共享资源进行同步或控制对共享资源的访问。而在相同或不同的应用程序域中未能正确地使访问同步，则会导致出现一些问题：

1.  死锁：当两个线程中的每一个线程都在试图锁定另外一个线程已锁定的资源时，就会发生死锁。其中任何一个线程都不能继续执行。
2. 争用条件：两个或多个线程都可以到达并执行一个代码块的条件，根据哪个线程先到达代码，程序结果会差异很大。

需要同步的资源包括：

1) 系统资源（如通信端口）。

2) 多个进程所共享的资源（如文件句柄）。

3) 由多个线程访问的单个应用程序域的资源（如全局、静态和实例字段）。

线程同步锁”可以保护共享数据，但是也会存在一些问题：

1) 实现比较繁琐，而且容易错漏。你必须标识出可能由多个线程访问的所有共享数据。然后，必须为其获取和释放一个线程同步琐，并且保证已经正确为所有共享资源添加了锁定代码。

2) 由于临界区无法并发运行，进入临界区就需要等待，加锁带来效率的降低。

3) 在复杂的情况下，很容易造成死锁，并发实体之间无止境的互相等待。

4) 优先级倒置造成实时系统不能正常工作。优先级低的进程拿到高优先级进程需要的锁，结果是高/低优先级的进程都无法运行，中等优先级的进程可能在狂跑。

5) 当线程池中一个线程被阻塞时，可能造成线程池根据CPU使用情况误判创建更多的线程以便执行其他任务，然而新创建的线程也可能因请求的共享资源而被阻塞，恶性循环，徒增[线程上下文](http://www.cnblogs.com/heyuquan/archive/2012/12/23/2830214.html#context)切换的次数，并且降低了程序的伸缩性。**（这一点很重要）**

### 线程安全

使一个方法线程安全，并不是说它一定要在内部获取一个线程同步锁。一个线程安全的方法意味着在两个线程试图同时访问数据时，数据不会被破坏。如方法参数是值类型，会复制到方法内部，线程之间互不干涉。

### 原子操作

原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事物中断。

在多线程编程环境中指：一个线程在访问某个资源的同时能够保证没有其他线程会在同一时刻访问同一资源。

根据待同步粒度大小来选择合适的同步方式：

1. 易失结构

   volatile 关键字指示一个字段可以由多个同时执行的线程修改。JIT编译器确保对易失字段的所有访问都是易失读取和易失写入的方式执行，而不用显示调用Thread的静态VolatileRead()与VolatileWrite()方法。

   另外，Volatile关键字告诉C#和JIT编译器不将字段缓存到CPU的寄存器中，确保字段的所有读取操作都在RAM中进行。（这也会降低一些性能）

   volatile也带来了一个问题，因为volatile标注的成员不受优化器优化。

   eg：m_amount=m_amount+m_amount // m_amount是类中定义的一个volatile字段

   通常，要倍增一个整数，只需将它的所有位都左移1位，许多编译器都能检测到上述代码的意图，并执行优化。然而，如果m_amount是volatile字段，就不允许执行这个优化，编译器必须生成代码将m_amount读入一个寄存器，再把它读入另一个寄存器，将两个寄存器加到一起，再将结果写回m_amount字段。未优化的代码肯定会更大，更慢。

   C#不支持以传引用的方式将volatile字段传给方法。有时为了利用CPU的寄存器和编译器的优化我们会采用下面两种原子操作。

2. 互锁结构

   互锁结构是由 Interlocked 类的静态方法对某个内存位置执行的简单原子操作，即提供同步对多个线程共享的变量的访问的方法。这些原子操作包括添加、递增和递减、交换、依赖于比较的条件交换、内存屏障，以及 32 位平台上的 64 位long值的读取操作。

   Interlocked的所有方法都建立了完美的内存栅栏。换言之，调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法调用之前执行；而这个调用之后的任何变量读取都在这个调用之后读取。

   ```C#
   public static class Interlocked
   {
       // 对两个 32|64 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。返回结果：location1的新值。
       public static int Add(ref int location1, int value);
       public static long Add(ref long location1, long value);
    
       // 以原子操作的形式递增|递减指定变量的值。返回结果：location1的新值。
       public static int Increment(ref int location);
       public static long Increment(ref long location);
       public static int Decrement(ref int location);
       public static long Decrement(ref long location);
    
       // 比较指定的location1和comparand是否相等，如果相等，则将location1值设置为value。返回结果：location1 的原始值。
       public static T CompareExchange<T>(ref T location1, T value, T comparand) where T : class;
       // 以原子操作的形式，将location1的值设置为value，返回结果：location1 的原始值。
       public static T Exchange<T>(ref T location1, T value) where T : class;
    
       // 内存栅栏
       /// 此方法在.NET Framework 4.5 中引入，它是 Thread.MemoryBarrier() 方法的包装。 
       public static void MemoryBarrier();
    
       // 返回一个以原子操作形式加载的 64 位值。location:要加载的 64 位值。
       public static long Read(ref long location);
       ……
   }
   ```

   注意：

   1) 在使用Add()、Increament()、Decrement()方法时可能出现溢出情况，则遵循规则：

      a)  如果 location=Int32.MaxValue，则 location+1 = Int32.MinValue，location+2=Int32.MinValue+1……。

      b)  如果 location=Int32.MinValue，则 location- 1 =Int32.MaxValue，location- 2 =Int32.MaxValue-1……

   2) Read(ref long location) 返回一个以原子操作形式加载的 64 位值。由于 64 位读取操作已经是原子的，因此 64 位系统上不需要 Read 方法。在 32 位系统上，64 位读取操作除非用 Read 执行，否则不是原子的。

   3) Exchange 和 CompareExchange 方法具有接受 object 类型的参数的重载。这重载的第一个参数都是 ref object，传递给此参数的变量严格类型化为object，

      ```C#
      int o=2;
      // 不能将第一个参数强制转换为object类型，否则编译报错“ref 或 out 参数必须是可赋值的变量”
      // 这实际是类型强制转换的一个细节，强制转换时编译器会生成一个临时引用，然后把这个临时引用传给一个和转换类型相同的引用，这个临时引用比较特别，它不能被赋值，所以会报“ref 或 out 参数必须是可赋值的变量”。
      Interlocked.Exchange(ref (object)o,new object());
       
      // 编译通过
      objectobj = (object)o;
      Interlocked.Exchange(ref obj, new object());
      ```

   4) 示例：

      在大多数计算机上，增加变量操作不是一个原子操作，需要执行下列步骤：

      a)     将实例变量中的值加载到寄存器中。

      b)     增加或减少该值。

      c)     在实例变量中存储该值。

      如果不使用 Increment 和 Decrement，线程可能会在执行完前两个步骤后被抢先。然后由另一个线程执行所有三个步骤。当第一个线程重新开始执行时，它改写实例变量中的值，造成第二个线程执行增减操作的结果丢失。（线程都维护着自己的寄存器）

3. Thread类为我们提供的VolatileRead()与VolatileWrite()静态方法

### 同步代码块(临界区)

#### Monitor(监视器)

Monitor（监视器）放置多个线程同时执行代码块。Enter 方法允许一个且仅一个线程继续执行后面的语句；其他所有线程都将被阻止，直到执行语句的线程调用 Exit。

Monitor 锁定对象是引用类型，而非值类型，该对象用来定义锁的范围。若传递给 Exit 的被装箱对象不同于传递给 Enter 的被装箱的对象，所以 Monitor 将引发 SynchronizationLockException，并显示以下消息：“从不同步的代码块中调用了对象同步方法。”

Monitor将为每个同步对象来维护以下信息：

1) 对当前持有锁的线程的引用。

2) 对就绪队列的引用。当一个线程尝试着lock一个同步对象的时候，该线程就在就绪队列中排队。一旦没人拥有该同步对象，就绪队列中的线程就可以占有该同步对象。（队列：先进先出）

3) 对等待队列的引用。占有同步对象的线程可以暂时通过Wait()释放对象锁，将其在等待队列中排队。该队列中的线程必须通过Pulse()\PulseAll()方法通知才能进入到就绪队列。（队列：先进先出）

```C#
public static class Monitor
{
    // 确定当前线程是否保留指定对象锁。
    public static bool IsEntered(object obj);
    // 获取指定对象上的排他锁（设置获取锁的结果lockTaken，通过引用传递。 输入必须为 false。 如果已获取锁，则输出为 true；否则输出为 false）
    public static void Enter(object obj);
    public static void Enter(object obj, ref bool lockTaken);        
    // 在指定的一段时间内，尝试获取指定对象上的排他锁. 
    // (设置获取锁的结果lockTaken，通过引用传递。 输入必须为 false。如果已获取锁，则输出为 true；否则输出为 false)
    // System.TimeSpan，表示等待锁所需的时间量。 值为 -1 毫秒表示指定无限期等待。
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, TimeSpan timeout, ref bool lockTaken);
 
    // 释放指定对象上的排他锁。
    public static void Exit(object obj);
 
    // 释放对象上的锁并阻止当前线程，直到它重新获取该锁。 System.TimeSpan，表示线程进入就绪队列之前等待的时间量。
    // exitContext标识可以在等待之前退出同步上下文的同步域，随后重新获取该域。
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
 
    //  通知等待队列中的线程锁定对象状态的更改。
    public static void Pulse(object obj);
    // 通知所有的等待线程对象状态的更改。
    public static void PulseAll(object obj);
    ……
}
```

注意：

1) 同一线程在不阻止的情况下允许多次调用 Enter()；但在该对象上等待的其他线程取消阻止之前必须调用相同数目的 Exit()。

2) 如果释放了锁并且其他线程处于该对象的【就绪队列】中，则其中一个线程将获取该锁。如果其他线程处于【等待队列】中，则它们不会在锁的所有者调用 Exit ()时自动移动到就绪队列中。

3) 唤醒机制：Wait()释放参数指定对象的对象锁，以便允许其他被阻塞的线程获取对象锁。调用Wait()的线程进入【等待队列】中，等待状态必须由其他线程调用方法Pulse()或PulseAll()唤醒，使等待状态线程变为就绪状态。

   方法Pulse()和PulseAll()：向【等待队列】中第一个或所有等待线程发送信息，占用对象锁的线程准备释放对象锁。在即将调用Exit()方法前调用，通知等待队列线程移入就绪队列，待执行方法Exit()释放对象锁后被Wait()的线程将重新获取对象锁。

#### lock

lock 是.NET为简化Monitor（监视器）而存在的关键字。等价于：

```C#
Boolean lockTaken=false;
try
{
    Mnoitor.Enter(锁定对象,ref lockTaken);
    ……
}
Finally
{
    if(lockTaken)
        Monitor.Exit(锁定对象);
}
```

lock比Monitor更简洁，但Monitor提供了更多的方法，对获得锁的过程有更多的控制，如超时。

#### 获得独占锁的流程图

![image](images/31013412-8115781c38474e35adbaa463d7f5c624.png)

双检锁(Double-Check Locking)，单例模式

```C#
class Program
{
    private static Singleton s_value = null;
 
    static void Main(string[] args)
    {
        ThreadPool.QueueUserWorkItem((obj) => { Singleton.GetSingleton(); });
        ThreadPool.QueueUserWorkItem((obj) => {
            while (true)
            {
                if (s_value != null)
                {
                    Console.WriteLine("s_lock不为null");
                    break;
                }
            }
        });
 
        Console.Read();
    }
 
    public sealed class Singleton
    {
        private static Object s_lock = new object();
        
        // 私有构造器，阻止这个类外部的任何代码创建实例
        private Singleton() {
            Thread.SpinWait(Int32.MaxValue);
            Console.WriteLine("对象创建完成");
        }
 
        public static Singleton GetSingleton()
        {
            if (s_value != null) return s_value;
 
            Monitor.Enter(s_lock);
            if (s_value == null)
            {
                s_value = new Singleton();
                //Singleton temp = new Singleton();
                //Interlocked.Exchange(ref s_value, temp);
                Console.WriteLine("赋值完成");
            }
            Monitor.Exit(s_lock);
            return s_value;
        }
    }
}
```

1) 里面有两个if，当第一个if判断存在对象时就快速返回，就不需线程同步。如果第一个if判断对象还没创建好，就会获取一个线程同步锁来确保只有一个线程构造单实例函数。

2) 细腻的你可能认为会出现一种情况：第一个if将s_value空值读入到一个CPU寄存器中，而到第二个if读取s_value时也是从寄存器中读取该空值，但此时s_value内存中的值可能已经不为空了。

   CLR已经帮我们解决了这个问题，在CLR中任何锁的调用构成了一个完整的内存栅栏，在栅栏之前写入的任何变量都必须在栅栏之前完成；在栅栏之后的任何变量都必须在栅栏之后开始。即此处的Monitor.Enter()使s_value之前寄存器中的缓存无效化，需重新从内存中读取。

3. **执行完构造函数后才会将变量引用返回**，不需要使用Interlocked.Exchange方法.

4.  代码中没有使用try-catch-finally确保锁总是得以释放。原因： (所以我们要避免使用lock关键字)

   a)  在try块中，如果在更改状态的时候发生了一个异常，这个状态处于损坏状态。锁在finally块中退出时，另一个线程可能操作损坏的状态。

   b)  进入和离开try块也会影响方法的性能。

### 特性

利用特性进行上下文同步和方法同步：应用SynchronizaitonAttribute的类，CLR会自动对这个类实施同步机制。为当前上下文和所有共享同一实例的上下文强制一个同步域(在任一时刻，最多只有一个线程处于同步域中)。

被应用SynchronizationAttribute的类必须是上下文绑定的。换句话说，它必须继承于System.ContextBoundObject类

一般类所建立的对象为上下文灵活对象（context-agile），它们都由CLR自动管理，可存在于任意的上下文当中（一般在默认上下文中）。而 ContextBoundObject 的子类所建立的对象只能在建立它的对应上下文中正常运行，此状态被称为上下文绑定。其他对象想要访问ContextBoundObject 的子类对象时，都只能通过透明代理来操作。

```C#
using System.Runtime.Remoting.Contexts;
class Synchronization_Test
{
    public static void Test()
    {
        class1 c = new class1();
        ThreadPool.QueueUserWorkItem(o => { c.Test1(); });
        Thread.Sleep(100);
        ThreadPool.QueueUserWorkItem(o => { c.Test2(); });
    }
 
    [Synchronization(SynchronizationAttribute.REQUIRED)]  
    internal class class1 : ContextBoundObject
    {// 必须继承于System.ContextBoundObject类
        public void Test1()
        {
            Thread.Sleep(1000);
            Console.WriteLine("Test1");
            Console.WriteLine("1秒后");
         }
 
        public void Test2()
        {
            Console.WriteLine("Test2");
        }
    }
}
```

### 同步基元

基元线程同步构造分为：基元用户模式构造和基元内核模式构造。

1. 基元用户模式构造：应尽量使用基元用户模式构造，因为它们使用特殊的CPU指令来协调线程，这种协调发生硬件中，速度很快。但也因此Windows操作系统永远检测不到一个线程在一个用户模式构造上阻塞了，这种检测不到有利有弊：

   \1)     利：因为用户模式构造上阻塞的一个线程，池线程永远不认为已经阻塞，所以不会出现“线程池根据CPU使用情况误判创建更多的线程以便执行其他任务，然而新创建的线程也可能因请求的共享资源而被阻塞，恶性循环，徒增线程上下文切换的次数”的问题。

   \2)     弊：当你想要取得一个资源但又短时间取不到时，一个线程会一直在用户模式中运行，造成CPU资源的浪费，此时我们更希望像内核模式那样停止一个线程的运行让出CPU。

   **有：volatile关键字、Interlocked静态类、Thread的VolatileWrite()与VolatileRead()方法。**

2. 基元内核模式构造：是Windows操作系统自身提供的。

   它们要求我们调用在操作系统内核中实现的函数，调用线程将从托管代码转换为本地用户模式代码，再转换为本地内核模式代码，然后还要朝相反的方向一路返回，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。

   内核模式的构造具有基元用户模式构造所不具有的一些优点：

   \1)     一个内核模式的构造检测到在一个资源上的竞争时，Windows会阻塞输掉的线程，使它不占着一个CPU“自旋”，无谓地浪费处理器资源。

   \2)     内核模式的构造可实现本地和托管线程相互之间的同步。

   \3)     内核模式的构造可同步在一台机器的不同进程中运行的线程。

   \4)     内核模式的构造可应用安全性设置，防止未经授权的帐户访问它们。

   \5)     一个线程可一直阻塞，直到一个集合中的所有内核模式的构造都可用，或者直到一个集合中的任何一个内核模式的构造可用。

   \6)     在内核模式的构造上阻塞的一个线程可以指定一个超时值；如果在指定的时间内访问不到希望的资源，线程可以解除阻塞并执行其他任务。

   **有：EventWaitHandle(以及AutoResetEvent与ManualResetEvent)、Mutex、Semaphore。（另外：ReaderWriterLock）**

- 混合构造

  对于在一个构造上等待的线程，如果拥有这个构造的线程一直不释放它，则会出现：

  \1)     如果是用户模式构造，则线程将一直占用CPU，我们称之为“活锁”。

  \2)     如果是内核模式构造，则线程将一直被阻塞，我们称之为“死锁”。

  然后两者之间，死锁总是优于活锁，因为活锁既浪费CPU时间，又浪费内存。而死锁只浪费内存。

  混合构造正是为了解决这种场景。其通过合并用户模式和内核模式实现：

  1. 在没有线程竞争的时候，混合构造提供了基元用户模式构造所具有的性能优势。
  2. 多个线程同时竞争一个构造的时候，混合构造则使用基元内核模式的构造来提供不“自旋”的优势。
  3. 由于在大多数应用程序中，线程都很少同时竞争一个构造，所以在性能上的增强可以使你的应用程序表现得更出色。

  混合结构优化的本质：**两阶段等待操作**（自旋减少线程的上下文切换）

  a). 线程上下文切换需要花费几千个周期(每当线程等待内核事件WaitHandle时都会发生)。我们暂且称其为C。假如线程所等待的时间小于2C(1C用于等待自身，1C用于唤醒)，则自旋等待可以降低等待所造成的系统开销和滞后时间，从而提升算法的整体吞吐量和可伸缩性。

  b). 在多核计算机上，当预计资源不会保留很长一段时间时，如果让等待线程以用户模式旋转数十或数百个周期，然后重新尝试获取资源，则效率会更高。如果在旋转后资源变为可用的，则可以节省数千个周期。如果资源仍然不可用，则只花费了少量周期，并且仍然可以进行基于内核的等待。这一旋转-等待的组合称为“两阶段等待操作”。

  **有：Monitor\lock，ManualResetEventSlim、SemaphoreSlim、CountdownEvent、Barrier、ReaderWriterLockSlim。**

### 协作式取消

CancellationTokenSource和cancellationToken。它们常常被用于混合结构中。Eg：使一个线程强迫解除其构造上的等待阻塞。

取消过程：

1. 通过使用CancellationTokenSource创建一个或多个取消标记CancellationToken（cancellationToken可在线程池中线程或 Task 对象之间实现协作取消），
2. 然后将此取消标记传递给应接收取消通知的任意数量的线程或Task对象。
3. 当调用CancellationToken关联的CancellationTokenSource对象的 Cancle()时，每个取消标记(CancellationToken)上的IsCancellationRequested属性将返回true。
4. 异步操作中可以通过检查此属性做出任何适当响应。

#### CancellationTokenSource

```C#
// 通知System.Threading.CancellationToken，告知其应被取消。
public class CancellationTokenSource : IDisposable
{
    // 构造一个CancellationTokenSource将在指定的时间跨度后取消。
    public CancellationTokenSource(int millisecondsDelay);
 
    // 获取是否已请求取消此CancellationTokenSource。
    public bool IsCancellationRequested { get; }
     
    // 获取与此CancellationTokenSource关联的CancellationToken。
    public CancellationToken Token { get; }
 
    // 传达取消请求。参数throwOnFirstException:指定异常是否应立即传播。
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    // 在此CancellationTokenSource上等待指定时间后“取消”操作。
    public void CancelAfter(int millisecondsDelay);
 
    // 创建一组CancellationToken关联的CancellationTokenSource。
    public static CancellationTokenSource CreateLinkedTokenSource(paramsCancellationToken[] tokens);
 
    // 释放由CancellationTokenSource类的当前实例占用的所有资源。
    public void Dispose();
    ……
}
```

1) CancellationTokenSource.CreateLinkedTokenSource()方法

   将一组CancellationToken连接起来并创建一个新的CancellationTokenSource。任何一个CancellationToken对应的旧CancellationTokenSource被取消，这个新的CancellationTokenSource对象也会被取消。

   原理：创建一个新的CancellationTokenSource实例，并将该实例的Cancel()委托分别传递给这组CancellationToken实例的Register()方法，然后返回新创建的CancellationTokenSource实例。

2) CancellationTokenSource实例Cancel()方法做了什么：

   a)     将CancellationTokenSource实例的IsCancellationRequested属性设置为true。CancellationToken实例的IsCancellationRequested属性是调用CancellationTokenSource实例的IsCancellationRequested属性。

   b)     调用CancellationTokenSource实例的CreateLinkedTokenSource()注册的Cancel()委托回调；

   c)     调用CancellationToken实例的Register()注册的回调；

   d)     处理回调异常。（参数throwOnFirstException）

   ​        i.  若为Cancel()传递true参数，那么抛出了未处理异常的第一个回调方法会阻止其他回调方法的执行，异常会立即从Cancel()中抛出；

   ​       ii. 若为Cancel()传递false（默认为false），那么登记的所有回调方法都会调用。所有未处理的异常都会封装到一个AggregateException对象中待回调都执行完后返回，其InnerExceptions属性包含了所有异常的详细信息。

   e)   给CancellationToken对象的ManualResetEvent对象Set()信号。

#### CancellationToken

```C#
// 传播有关应取消操作的通知。
public struct CancellationToken
{
    public CancellationToken(bool canceled);
    public static CancellationToken None { get; }
 
    // 获取此标记是否能处于已取消状态。
    public bool CanBeCanceled { get; }
    // 获取是否已请求取消此标记。
    public bool IsCancellationRequested { get; }
 
    // 获取内部ManualResetEvent，在CancellationTokenSource执行Cancel()时收到set()通知。
    public WaitHandle WaitHandle{ get; }
 
    // 注册一个将在取消此CancellationToken时调用的委托。
    // 参数:useSynchronizationContext:
    //一个布尔值，该值指示是否捕获当前SynchronizationContext并在调用 callback 时使用它。
    public CancellationTokenRegistration Register(Action<object> callback, object state
                            , bool useSynchronizationContext);
 
    // 如果已请求取消此标记，则引发OperationCanceledException。
    public void ThrowIfCancellationRequested();
    ……
}
```

1) CancellationToken是结构struct，值类型。

2) CancellationTokenSource与CancellationToken关联是“一一对应”的

   a)     无论CancellationTokenSource是通过构造函数创建还是CreateLinkedTokenSource()方法创建，与之对应的CancellationToken只有一个。

   b)     每个CancellationToken都会包含一个私有字段，保存唯一与之对应的CancellationTokenSource引用。

3) CancellationToken实例的None属性与参数不是true的CancellationToken构造函数

   它们返回一个特殊的CancellationToken实例，该实例不与任何CancellationTokenSource实例关联(即不可能调用Cancel())，其CanBeCanceled实例属性为false。

4) CancellationToken的Register()方法返回的CancellationTokenRegistration对象，可调用其Dispose()方法删除一个Register()登记的回调方法。

5) CancellationToken实例的WaitHandle属性

   会先判断若没有对应的CancellationTokenSource，则创建一个默认的CancellationTokenSource对象。然后再判断若没有内部事件等待句柄则new ManualResetEvent(false)，在CancellationTokenSource执行Cancel()时收到set()通知。;

6) CancellationToken实例的ThrowIfCancellationRequested()方法如下：

   ```C#
   public void ThrowIfCancellationRequested()
   {
       if (this.IsCancellationRequested)
       {
           throw new OperationCanceledException(
           Environment.GetResourceString("OperationCanceled"), this);
       }
   }
   ```

```C#
//线程池线程协作取消的例子
public static void ThreadPool_Cancel_test()
{
    CancellationTokenSource cts = new CancellationTokenSource();
 
    ThreadPool.QueueUserWorkItem(
        token =>
        {
            CancellationToken curCancelToken = (CancellationToken)token;
            while (true)
            {
                // 耗时操作
                Thread.Sleep(400);
                if (curCancelToken.IsCancellationRequested)
                {
                    break;   // 或者抛异常curCancelToken.ThrowIfCancellationRequested();
                }
            }
            Console.WriteLine(String.Format("线程{0}上，CancellationTokenSource操作已取消，退出循环"
                , Thread.CurrentThread.ManagedThreadId));
        }
        , cts.Token
     );
 
    ThreadPool.QueueUserWorkItem(
        token =>
        {
            Console.WriteLine(String.Format("线程{0}上，调用CancellationToken实例的WaitHandle.WaitOne() "
                 , Thread.CurrentThread.ManagedThreadId));
            CancellationToken curCancelToken = (CancellationToken)token;
            curCancelToken.WaitHandle.WaitOne();
            Console.WriteLine(String.Format("线程{0}上，CancellationTokenSource操作已取消，WaitHandle获得信号"
                 , Thread.CurrentThread.ManagedThreadId));
        }
        , cts.Token
     );
 
    Thread.Sleep(2000);
    Console.WriteLine("执行CancellationTokenSource实例的Cancel()");
    cts.Cancel();            
}
```

### 自旋结构

#### SpinWait自旋等待

一个轻量同步类型(结构体)，提供对基于自旋的等待的支持。SpinWait只有在多核处理器下才具有使用意义。在单处理器下，自旋转会占据CPU时间，却做不了任何事

多任务或线程中，每一个任务或线程都应该使用自己的SpinWait实例

```C#
public struct SpinWait
{
    // 获取已对此实例调用SpinWait.SpinOnce() 的次数。
    public int Count { get; }
    // 判断对SpinWait.SpinOnce() 的下一次调用是否触发上下文切换和内核转换。
    public bool NextSpinWillYield
    {
        get
        {
            if (this.m_count<= 10)  // 自旋转计数
            {
                return Environment.ProcessorCount == 1;
            }
            return true;
        }
    }
 
    // 重置自旋计数器。
    public void Reset();
    // 执行单一自旋。
    public void SpinOnce()
    {
        if (this.NextSpinWillYield)
        {
            Int num = (this.m_count>= 10) ? (this.m_count - 10) :this.m_count;
            if ((num % 20) == 0x13)
            {
                Thread.Sleep(1);
            }
            else if ((num % 5) == 4)
            {
                Thread.Sleep(0);
            }
            else
            {
                Thread.Yield();
            }
        }
        else
        {
            Thread.SpinWait(((int) 4) <<this.m_count);
        }
        this.m_count = (this.m_count == 0x7fffffff) ?10 : (this.m_count + 1);
    }
    // 在指定条件得到满足(Func<bool>委托返回true)之前自旋。
    public static void SpinUntil(Func<bool> condition);
    // 在指定条件得到满足或指定超时过期之前自旋。参数condition为在返回 true 之前重复执行的委托。
    // 返回结果:
    // 如果条件在超时时间内得到满足，则为 true；否则为 false
    public static bool SpinUntil(Func<bool> condition, int millisecondsTimeout);
    public static bool SpinUntil(Func<bool> condition, TimeSpan timeout);
}
```

1) SpinWait自旋转是调用Thread.SpinWait()。

2) 由NextSpinWillYield属性代码可知，若SpinWait运行在单核计算机上，它总是进行上下文切换（让出处理器）。

3) SpinWait不仅仅是一个空循环。它经过了精心实现，可以针对一般情况提供正确的旋转行为以避免内核事件所需的高开销的上下文切换和内核转换；在旋转时间足够长的情况下自行启动上下文切换，SpinWait甚至还会在多核计算机上产生线程的时间片（Thread.Yield()）以防止等待线程阻塞高优先级的线程或垃圾回收器线程。

4) SpinOnce()自旋一定次数后可能导致频繁上下文切换。注意只有等待时间非常短时，SpinOnce()或SpinUntil()提供的智能行为才会获得更好的效率，否则您应该在SpinWait自行启动上下文切换之前调用自己的内核等待。

   通常使用SpinWait来封装自己“两阶段等待操作”，避免内核事件所需的高开销的**上下文切换和内核转换**。

   实现自己的“**两阶段等待操作**”：

   ```C#
   if (!spinner.NextSpinWillYield)
   {spinner.SpinOnce();}
   else
   {自己的事件等待句柄;}
   ```

#### SpinLock自旋锁

一个轻量同步类型，提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。SpinLock是结构体，如果您希望两个副本都引用同一个锁，则必须通过引用显式传递该锁。

```C#
public struct SpinLock
    {
        // 初始化SpinLock结构的新实例,参数标识是否启动线程所有权跟踪以助于调试。
        public SpinLock(bool enableThreadOwnerTracking);
 
        // 获取锁当前是否已由任何线程占用。
        public bool IsHeld { get; }
        // 获取是否已为此实例启用了线程所有权跟踪。
        public bool IsThreadOwnerTrackingEnabled { get; }
        // 若IsThreadOwnerTrackingEnabled=true，则可获取锁是否已由当前线程占用。
        public bool IsHeldByCurrentThread { get; }
 
        // 采用可靠的方式获取锁，这样，即使在方法调用中发生异常的情况下，都能采用可靠的方式检查lockTaken以确定是否已获取锁。
        public void Enter(ref boollockTaken);
        public void TryEnter(ref boollockTaken);
        public void TryEnter(int millisecondsTimeout, ref bool lockTaken);
        public void TryEnter(TimeSpan timeout, ref bool lockTaken);
        // Enter(ref boollockTaken)与TryEnter(ref bool lockTaken)效果一样，TryEnter(ref boollockTaken)会跳转更多方法降低的性能。
 
        // 释放锁。参数useMemoryBarrier：指示是否应发出内存屏障，以便将退出操作立即发布到其他线程（默认为true）。
        public void Exit();
        public void Exit(bool useMemoryBarrier);
}
```

1) SpinLock支持线程跟踪模式，可以在开发阶段使用此模式来帮助跟踪在特定时间持有锁的线程。虽然线程跟踪模式对于调试很有用，但此模式可能会导致性能降低。（构造函数：可接受一个bool值以指示是否启用调试模式，跟踪线程所有权）

2) SpinLock不可重入。在线程进入锁之后，它必须先正确地退出锁，然后才能再次进入锁。通常，任何重新进入锁的尝试都会导致死锁。

   如果在调用 Exit 前没有调用 Enter，SpinLock的内部状态可能被破坏。

3) Enter与TryEnter的选择

   a)     Enter(ref boollockTaken)     在获取不到锁时会阻止等待锁可用，自旋等待，相当于等待时间传入-1（即无限期等待）。

   b)     TryEnter(ref boollockTaken) 在获取不到锁时立即返回而不行进任何自旋等待，相当于等待时间传入0。

   c)     TryEnter(时间参数, ref boollockTaken)      在获取不到锁时，会在指定时间内自旋等待。

   d)     在指定时间内，若自旋等待足够长时间，内部会自动切换上下文进行内核等待，切换逻辑类似SpinWait结构（即，并没有使用等待事件，只是使用Thread.Sleep(0)、Thread.Sleep(1)以及Thread.Yield()），所以也可能导致频繁上下文切换。

4) 在多核计算机上，当等待时间预计较短且极少出现争用情况时，SpinLock的性能将高于其他类型的锁(长时或预期有大量阻塞，由于旋转过多，性能会下降)。但需注意的一点是，**SpinLock比标准锁更耗费资源。建议您仅在通过分析确定 Monitor方法或 Interlocked 方法显著降低了程序的性能时使用SpinLock****。**

5) 在保持一个自旋锁时，应避免任何这些操作：

   a)     阻塞，

   b)     调用本身可能阻塞的任何内容，

   c)     一个SpinLock结构上保持过多自旋锁，

   d)     进行动态调度的调用（接口和虚方法）

   e)     非托管代码的调度，或分配内存。

6) **不要将SpinLock声明为只读字段，因为如果这样做的话，会导致每次调用这个字段都返回SpinLock的一个新副本，而不是同一个SpinLock。这样所有对Enter()的调用都能成功获得锁，因此受保护的临界区不会按照预期进行串行化。**

