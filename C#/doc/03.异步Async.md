### 原理

函数执行时，一旦遇到await就会返回。等到触发的异步操作完成，再接着执行函数体内后面的语句。

**await语句后面的代码，相当于回调函数**

### 示例

```c#
//Caller
private void button1_Click(object sender, EventArgs e)
{
    Console.WriteLine("CallerChild1. My Thread ID is :" + Thread.CurrentThread.ManagedThreadId);
    var ResultTask  = AsyncMethod();
    // 此处会发生死锁， 
    Console.WriteLine(ResultTask.Result);
    // await修饰的Task/Task<TResult>得到的是TResult。
    Console.WriteLine(await ResultTask);
    Console.WriteLine("CallerChild2. My Thread ID is :" + Thread.CurrentThread.ManagedThreadId);
}

//CalleeAsync
private async Task<string> AsyncMethod()
{
    Console.WriteLine("CalleeChild1");
    var ResultFromTimeConsumingMethod = TimeConsumingMethod();
    string Result = await ResultFromTimeConsumingMethod + " + AsyncMethod. My Thread ID is :" + Thread.CurrentThread.ManagedThreadId;
    Console.WriteLine("CalleeChild2"+Result);
    return Result;
}

//这个函数就是一个耗时函数，可能是IO操作，也可能是cpu密集型工作。
private Task<string> TimeConsumingMethod()
{            
    var task = Task.Run(()=> {
        Console.WriteLine("Helo I am TimeConsumingMethod. My Thread ID is :" + Thread.CurrentThread.ManagedThreadId);
        Thread.Sleep(5000);
        Console.WriteLine("Helo I am TimeConsumingMethod after Sleep(5000). My Thread ID is :" + Thread.CurrentThread.ManagedThreadId);
        return "Hello I am TimeConsumingMethod";
    });
    return task;
}
```

### 流程

1. Caller函数被调用，先执行CallerChild1代码，这里是同步执行与一般函数一样，然后遇到了异步函数CalleeAsync。
2. 在CalleeAsync函数中有await关键字，await的作用是打分裂点。
3. 编译器会把整个函数（CalleeAsync）从这里分裂成两个函数。await关键字之前的代码作为一个函数（CalleeChild1）await关键字之后的代码作为一个函数（CalleeChild2）。
4. CalleeChild1在调用方线程执行（在示例中就是主线程Thread1），执行到await关键字之后，另开一个线程耗时工作在Thread3中执行，然后立即返回。
5. 调用方会继续执行下面的代码CallerChild2（注意是Caller不是Callee）
6. 在CallerChild2被执行期间，TimeConsumingMethod也在异步执行（可能是在别的线程也可能是CPU不参与操作直接DMA的IO操作）

![img](images/871381-20181228112659970-82597199.png)

### 应用

`Task`的`TaskContinueWith`方法的实现

```C#
private void button1_Click(object sender, EventArgs e)
{
    var ResultTask = Task.Run(()=> {
        Console.WriteLine("Helo I am TimeConsumingMethod. My Thread ID is :" + Thread.CurrentThread.ManagedThreadId);
        Thread.Sleep(5000);
        return "Hello I am TimeConsumingMethod";
    });

    ResultTask.ContinueWith(OnDoSomthingIsComplete);
}

private void OnDoSomthingIsComplete(Task<string> t)
{
    Action action = () => {
        textBox1.Text = t.Result;
    };
    textBox1.Invoke(action);
    Console.WriteLine("Continue Thread ID :" + Thread.CurrentThread.ManagedThreadId);
}
```

async & await 的实现

```C#
private async void button1_Click(object sender, EventArgs e)
{
    var t = Task.Run(() => {
        Thread.Sleep(5000);
        return "Hello I am TimeConsumingMethod";
    });
    textBox1.Text = await t;
}
```

### 参考

进一步考察是否理解执行顺序：https://blog.csdn.net/qq_35735344/article/details/79876480